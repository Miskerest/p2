package cmsc433.p2;

import java.util.HashMap;
import java.util.List;

import cmsc433.p2.SimulationEvent;


/**
 * Validates a simulation
 */
public class Validate {
	
	private static final int COOK_STARTING = 0;
	private static final int COOK_RECEIVED_ORDER = 1;
	private static final int COOK_STARTED_FOOD = 2;
	private static final int COOK_FINISHED_FOOD = 3;
	private static final int COOK_COMPLETED_ORDER = 4;
	private static final int COOK_FINISHED = 5;
	
	private static final int CUSTOMER_STARTING = 0;
	private static final int CUSTOMER_ENTERED = 1;
	private static final int CUSTOMER_PLACED_ORDER = 2;
	private static final int CUSTOMER_RECEIVED_ORDER = 3;
	private static final int CUSTOMER_LEFT = 4;
	
	private static class InvalidSimulationException extends Exception {
		private static final long serialVersionUID = 1L;

		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");

			int numCustomers = events.get(0).simParams[0];
			int numCooks = events.get(0).simParams[1];
			int numTables = events.get(0).simParams[2];
			int capacity = events.get(0).simParams[3];

			check(events.get(events.size()-1).event == 
					SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");

			int numCustomersSim = 0, numCooksSim = 0;

			int numDinersCount = 0;

			int numCurrentOrders = 0;

			int numWorkingOrders = 0;
			
			int numWorkingFood = 0;
			
			int numWings = 0, numPizza = 0, numSub = 0, numSoda = 0;
			
			HashMap<Customer, Integer> customerStatus = new HashMap<Customer, Integer>();
			HashMap<Cook, Integer> cookStatus = new HashMap<Cook, Integer>();
			
			int numTotalOrders = 0;
			
			for (int i = 0; i < events.size(); i++) {
				SimulationEvent event = events.get(i);
				switch (event.event) {
				/* General events */
				case SimulationStarting:
					break;
				case SimulationEnded:
					break;
					/* Customer events */
				case CustomerStarting:
					numCustomersSim++;
					customerStatus.put(event.customer, CUSTOMER_STARTING);
				break;
				case CustomerEnteredRatsies:
					numDinersCount++;
					check(numDinersCount<=numCustomers, "More customers dining in than defined. " + event.customer + ", " + numDinersCount);
					check(customerStatus.get(event.customer) == CUSTOMER_STARTING, "Customer entered without starting. " + event.customer + ", " + customerStatus.get(event.customer));
					customerStatus.put(event.customer, CUSTOMER_ENTERED);
				break;
				case CustomerPlacedOrder:
					numCurrentOrders++;
					numTotalOrders++;
					check(numCurrentOrders<=numTables, "More orders than there are tables. " + event.customer + ", " + numCurrentOrders + "/" + numTables);
					check(customerStatus.get(event.customer) == CUSTOMER_ENTERED, "Customer ordered without entering. " + event.customer + ", " + customerStatus.get(event.customer));
					customerStatus.put(event.customer, CUSTOMER_PLACED_ORDER);
					break;
				case CustomerReceivedOrder:
					numCurrentOrders--;
					check(customerStatus.get(event.customer) == CUSTOMER_PLACED_ORDER, "Customer received order without ordering. " + event.customer + ", " + customerStatus.get(event.customer));
					customerStatus.put(event.customer, CUSTOMER_RECEIVED_ORDER);
					break;
				case CustomerLeavingRatsies: 
					numDinersCount--;
					check(customerStatus.get(event.customer) == CUSTOMER_RECEIVED_ORDER, "Customer left without receiving order. " + event.customer + ", " + customerStatus.get(event.customer));
					customerStatus.put(event.customer, CUSTOMER_LEFT);
				break;
				/* Cook Events */
				case CookStarting: 
					numCooksSim++;
					cookStatus.put(event.cook, COOK_STARTING);
					break;
				case CookReceivedOrder: 
					numWorkingOrders++;
					check(numWorkingOrders<=numCooks, "More orders being worked on than there are cooks. " + event.cook + ", " + numWorkingOrders + "/" + numCooks);
					check(cookStatus.get(event.cook) == COOK_STARTING || cookStatus.get(event.cook) == COOK_COMPLETED_ORDER || cookStatus.get(event.cook) == COOK_FINISHED, 
							"Cook received order without starting. " + event.cook + ", " + cookStatus.get(event.cook));
					cookStatus.put(event.cook, COOK_RECEIVED_ORDER);
					break;
				case CookStartedFood:
					check(cookStatus.get(event.cook) == COOK_RECEIVED_ORDER || cookStatus.get(event.cook) == COOK_STARTED_FOOD, 
					"Cook started food without receiving order. " + event.cook + ", " + cookStatus.get(event.cook));
					cookStatus.put(event.cook, COOK_STARTED_FOOD);
					break;
				case CookFinishedFood:
					check(cookStatus.get(event.cook) == COOK_STARTED_FOOD || cookStatus.get(event.cook) == COOK_FINISHED_FOOD, 
					"Cook finished food without starting food. " + event.cook + ", " + cookStatus.get(event.cook));
					cookStatus.put(event.cook, COOK_FINISHED_FOOD);
					break;
				case CookCompletedOrder:
					check(cookStatus.get(event.cook) == COOK_RECEIVED_ORDER || cookStatus.get(event.cook) == COOK_FINISHED_FOOD,
					"Cook completed order without finishing food. " + event.cook + ", " + cookStatus.get(event.cook) + " orderNumber: " + event.orderNumber);
					cookStatus.put(event.cook, COOK_COMPLETED_ORDER);
					numWorkingOrders--;
				break;
				case CookEnding:
					cookStatus.put(event.cook, COOK_FINISHED);
					break;
					/* Machine events */
				case MachineStarting:
					break;
				case MachineStartingFood:
					numWorkingFood++;
					check(numWorkingFood<=4*capacity, "More food items being worked on than machine capacity. " + event.machine + ", " + numWorkingFood + "/" + (4*capacity));
					if (event.machine.machineFoodType == FoodType.wings) {
						numWings++;
						check(numWings<=capacity, "More wings being worked on than machine capacity. " + event.machine + ", " + numWings + "/" + capacity);
					} else if (event.machine.machineFoodType == FoodType.sub) {
						numSub++;
						check(numSub<=capacity, "More subs being worked on than machine capacity. " + event.machine + ", " + numSub + "/" + capacity);
					} else if (event.machine.machineFoodType == FoodType.pizza) {
						numPizza++;
						check(numPizza<=capacity, "More pizzas being worked on than machine capacity. " + event.machine + ", " + numPizza + "/" + capacity);
					} else if (event.machine.machineFoodType == FoodType.soda) {
						numSoda++;
						check(numSoda<=capacity, "More sodas being worked on than machine capacity. " + event.machine + ", " + numSoda + "/" + capacity);
					}
					break;
				case MachineDoneFood:
					numWorkingFood--;
					if (event.machine.machineFoodType == FoodType.wings) {
						numWings--;
					} else if (event.machine.machineFoodType == FoodType.sub) {
						numSub--;
					} else if (event.machine.machineFoodType == FoodType.pizza) {
						numPizza--;
					} else if (event.machine.machineFoodType == FoodType.soda) {
						numSoda--;
					}
					break;
				case MachineEnding:   
					break;
				}

			}

			check(numCustomers == numCustomersSim, "More customers than defined.");
			check(numCooks == numCooksSim, "More cooks than defined.");
			check(numTotalOrders == numCustomers, "More orders than customers.");

			/* In P2 you will write validation code for things such as:
				Should not have more eaters than specified
				Should not have more cooks than specified
				The Ratsie's capacity should not be exceeded
				The capacity of each machine should not be exceeded
				Eater should not receive order until cook completes it
				Eater should not leave Ratsie's until order is received
				Eater should not place more than one order
				Cook should not work on order before it is placed
			 */

			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}
