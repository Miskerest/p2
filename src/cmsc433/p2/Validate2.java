package cmsc433.p2;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;


/**
 * Validates a simulation
 */
public class Validate2 {
	
	private enum OrderStatus {
		Placed,
		Cooking,
		Complete
	};
	
	private enum CustomerStatus {
		Created,
		Entered,
		PlacedOrder,
		ReceivedOrder,
		Left
	};
	
	private static class InvalidSimulationException extends Exception {
		private static final long serialVersionUID = 1L;

		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate2.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {

			/* In P2 you will write validation code for things such as:
				Should not have more eaters than specified
				Should not have more cooks than specified
				The Ratsie's capacity should not be exceeded
				The capacity of each machine should not be exceeded
				Eater should not receive order until cook completes it
				Eater should not leave Ratsie's until order is received
				Eater should not place more than one order
				Cook should not work on order before it is placed
			 */
			
			// Create a list of events that we will modify, remove the starting and ending events
			ArrayList<SimulationEvent> realEvents = new ArrayList<SimulationEvent>();
			realEvents.addAll(events);	
			
			int expectedNumCooks = 0;
			int expectedNumCustomer = 0;
			
			int machineCapacity = 0;
			int restaurantCapacity = 0;
			int restaurantUsage = 0;
			
			HashSet<String> cooks = new HashSet<String>();
			HashMap<Integer, OrderStatus> orderStatus = new HashMap<Integer, OrderStatus>();
			HashMap<String, CustomerStatus> customerStatus = new HashMap<String, CustomerStatus>();
			HashMap<Food, Integer> machineStatus = new HashMap<Food, Integer>();
			
			Integer index = 0;
			String currName;
			Integer currOrderNum;
			Integer machineUsage;
			for (SimulationEvent currEvent: realEvents) {
				switch(currEvent.event) {
					case CustomerStarting:
						currName = currEvent.customer.getName();
						check(customerStatus.size() < expectedNumCustomer, "Too many customers created");

						check(customerStatus.put(currName, CustomerStatus.Created) == null,
							"Duplicate Customer: " + currName);
						
					    break;
					case CustomerEnteredRatsies:
						currName = currEvent.customer.getName();
						
						check(restaurantUsage < restaurantCapacity, "Too many customers entered");
						
						check(
							customerStatus.put(currName, CustomerStatus.Entered) == CustomerStatus.Created,
							"Customer entered Ratsies before being created"
						);
					    break;
					case CustomerPlacedOrder:
						currName = currEvent.customer.getName();
						currOrderNum = currEvent.orderNumber;
						check(
							customerStatus.put(currName, CustomerStatus.PlacedOrder) == CustomerStatus.Entered,
							"Customer Placed Order before entering"
						);
						
						check(
							orderStatus.put(currOrderNum, OrderStatus.Placed) == null,
							"Duplicate Order"
						);
						
					    break;
					case CustomerReceivedOrder:
						currName = currEvent.customer.getName();
						currOrderNum = currEvent.orderNumber;
						
						check(
							customerStatus.put(currName, CustomerStatus.ReceivedOrder) == CustomerStatus.PlacedOrder,
							"Customer received order before placing it"
						);
						
						check(
							orderStatus.get(currOrderNum) == OrderStatus.Complete,
							"Customer got order before completion " + currOrderNum
						);
						
					    break;
					case CustomerLeavingRatsies:
						currName = currEvent.customer.getName();
						
						check(
							customerStatus.put(currName, CustomerStatus.Left) == CustomerStatus.ReceivedOrder,
							"Customer left before getting order"
						);
						
						restaurantUsage -= 1;
					    break;
					case CookStarting:
						currName = currEvent.cook.getName();
						check(!cooks.contains(currName),
							"Duplicate Cook: " + currName);
						
						check(cooks.size() < expectedNumCooks, "Too many cooks created");
						
						cooks.add(currName);
					    break;
					case CookReceivedOrder:
						currName = currEvent.cook.getName();
						currOrderNum = currEvent.orderNumber;
						
						check(cooks.contains(currName), "Nonexistent cook working on order");
						check(
							orderStatus.put(currOrderNum, OrderStatus.Cooking) == OrderStatus.Placed,
							"Orders started cooking before customer placed it"	
						);
					    break;
					case CookStartedFood: case CookFinishedFood:
						currName = currEvent.cook.getName();
						currOrderNum = currEvent.orderNumber;
						
						check(cooks.contains(currName), "Nonexistent cook working on order");
						check(
							orderStatus.get(currOrderNum) == OrderStatus.Cooking,
							"Cook started/finished food before starting order"	
						);
					    break;
					case CookCompletedOrder:
						currName = currEvent.cook.getName();
						currOrderNum = currEvent.orderNumber;
						
						check(cooks.contains(currName), "Nonexistent cook working on order");
						check(
							orderStatus.put(currOrderNum, OrderStatus.Complete) == OrderStatus.Cooking,
							"Cook completed order before starting cooking"	
						);
					    break;
					case CookEnding:
						currName = currEvent.cook.getName();
						check(cooks.contains(currName), "Nonexistent cook Ended");
					    break;
					case MachineStarting:
						check(
							machineStatus.put(currEvent.machine.machineFoodType, 0) == null,
							"Duplicate machine type: " + currEvent.machine.machineFoodType.name
						);
					    break;
					case MachineStartingFood:
						machineUsage = machineStatus.get(currEvent.machine.machineFoodType);
						
						check(machineUsage != null, "Nonexistent machine");
						
						check(
							machineUsage < machineCapacity,
							"Machine Exceeded Capacity: " + currEvent.machine.machineFoodType.name
						);
						
						machineStatus.put(currEvent.machine.machineFoodType, machineUsage + 1);
					    break;
					case MachineDoneFood:
						machineUsage = machineStatus.get(currEvent.machine.machineFoodType);

						check(machineUsage != null, "Nonexistent machine");
						
						check(
							machineUsage <= machineCapacity && machineUsage != 0,
							"Invalid machine usage: " + currEvent.machine.machineFoodType.name
						);
						
						machineStatus.put(currEvent.machine.machineFoodType, machineUsage - 1);
					    break;
					case MachineEnding:
						machineUsage = machineStatus.get(currEvent.machine.machineFoodType);

						check(machineUsage != null, "Nonexistent machine");
						check(machineUsage == 0, "Invalid Machine Usage. Shutting down, food should be done");
					    break;
					case SimulationEnded:
						check(index == realEvents.size() - 1, 
							"Simulation didn't end with termination event");
						break;
					case SimulationStarting:
						check(index == 0, "Simulation didn't start with initiation event");
						
						
						int [] params = currEvent.simParams;
						
						expectedNumCustomer = params[0];
						expectedNumCooks = params[1];
						
						restaurantCapacity = params[2];
						machineCapacity = params[3];
						
						break;
					default:
						check(false, "Invalid SimulationEvent type");
						break;
				}
				
				index += 1;
			}

			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}